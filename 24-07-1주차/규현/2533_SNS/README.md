# [Gold III] 사회망 서비스(SNS) - 2533 

[문제 링크](https://www.acmicpc.net/problem/2533) 

### 성능 요약

메모리: 82800 KB, 시간: 536 ms

### 분류

다이나믹 프로그래밍, 트리에서의 다이나믹 프로그래밍, 트리

### 제출 일자

2024년 7월 4일 11:28:31

### 문제 설명

<p>페이스북, 트위터, 카카오톡과 같은 사회망 서비스(SNS)가 널리 사용됨에 따라, 사회망을 통하여 사람들이 어떻게 새로운 아이디어를 받아들이게 되는가를 이해하는 문제가 중요해졌다. 사회망에서 사람들의 친구 관계는 그래프로 표현할 수 있는데,  이 그래프에서 사람은 정점으로 표현되고, 두 정점을 잇는 에지는 두 정점으로 표현되는 두 사람이 서로 친구 관계임을 표현한다. </p>

<p>예를 들어, 철수와 영희, 철수와 만수, 영희와 순희가 서로 친구 관계라면 이를 표현하는 친구 관계 그래프는 다음과 같다. </p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/c0d162b4-20d6-46eb-be8f-d06ae8bf1e9c/-/preview/" style="width: 203px; height: 81px;"></p>

<p>친구 관계 그래프를 이용하면 사회망 서비스에서 어떤 새로운 아이디어가 전파되는 과정을 이해하는데 도움을 줄 수 있다. 어떤 새로운 아이디어를 먼저 받아들인 사람을 얼리 아답터(early adaptor)라고 하는데, 사회망 서비스에 속한 사람들은 얼리 아답터이거나 얼리 아답터가 아니다. 얼리 아답터가 아닌 사람들은 자신의 모든 친구들이 얼리 아답터일 때만 이 아이디어를 받아들인다. </p>

<p>어떤 아이디어를 사회망 서비스에서 퍼뜨리고자 할 때, 가능한 한 최소의 수의 얼리 아답터를 확보하여 모든 사람이 이 아이디어를 받아들이게 하는  문제는 매우 중요하다. </p>

<p>일반적인 그래프에서 이 문제를 푸는 것이 매우 어렵다는 것이 알려져 있기 때문에, 친구 관계 그래프가 트리인 경우, 즉 모든 두 정점 사이에 이들을 잇는 경로가 존재하면서 사이클이 존재하지 않는 경우만 고려한다. </p>

<p>예를 들어, 8명의 사람으로 이루어진 다음 친구 관계 트리를 생각해보자. 2, 3, 4번 노드가 표현하는 사람들이 얼리 아답터라면, 얼리 아답터가 아닌 사람들은 자신의 모든 친구가 얼리 아답터이기 때문에 새로운 아이디어를 받아들인다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/ac2e6a89-2e66-4cab-8f07-951372ef7fcc/-/preview/" style="width: 191px; height: 127px;"></p>

<p>친구 관계 트리가 주어졌을 때, 모든 개인이 새로운 아이디어를 수용하기 위하여 필요한 최소 얼리 어답터의 수를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫 번째 줄에는 친구 관계 트리의 정점 개수 N이 주어진다. 단, 2 ≤ N ≤ 1,000,000이며, 각 정점은 1부터 N까지 일련번호로 표현된다. 두 번째 줄부터 N-1개의 줄에는 각 줄마다 친구 관계 트리의 에지 (u, v)를 나타내는 두 정수 u와 v가 하나의 빈칸을 사이에 두고 주어진다. </p>

### 출력 

 <p>주어진 친구 관계 그래프에서 아이디어를 전파하는데 필요한 얼리 아답터의 최소 수를 하나의 정수로 출력한다.</p>


---

# 풀이 설명

위의 백준 허브의 설명에서도 알 수 있겠지만 트리 형태로 문제가 주어진다. 그 상황에서 얼리 어덥터가 될 후보를 정해줘야 한다. 처음엔 위상 정렬같은 느낌인가? 라고 생각했는데, 그렇지는 않았다.

얼리 어덥터를 어떻게 선택할까? 라고 생각했을 때 2가지 방법을 생각했다.

첫 번쨰는 tree를 구성했을 때 연관된 친구들이 많은 사람들을 선택해서 얼리 어덥터로 만들어 주는 것.
두 번째는 연관된 친구가 1명 밖에 없는 애의 친구를 얼리 어덥터로 만들어 주는 것이다.

결과적으로는 2번 풀이를 선택했는데, 1번 풀이의 경우 약간의 허수가 껴 있을 수 있다고 생각했다. 내 친구들 중에 얼리 어덥터로 뽑힐 사람이 있다면, 그 수를 제외해줘야 한다고 생각했기 때문이다. 

2번 방식으로 진행하면서, 친구가 1명밖에 없는 사람은 그 상대 사람이 무조건 얼리 어덥터가 되어야 한다. 그래서 친구 카운터라는 배열을 만들어 주었다. 친구 카운터 배열은 `int[] life` 로 정의했는데, 이 값의 의미는 내 친구들 중에서 얼리 어덥터 후보의 수이다. 

그런 상황에서 `life` 의 값이 1이라면, 무조건 그 친구가 얼리 어덥터가 되어야 한다는 것이다.

이렇게 설정을 한 후 다음과 같이 진행했다.

1. life가 1인 친구를 queue에 넣는다. queue에서 poll이 될 때 life가 0이라면 continue, 아니라면 라이프를 1 깎는다 (라이프가 0이 된다.)
2. poll된 친구의 친구 그래프를 탐색하면서 얼리 어덥터가 될 수 있는 친구를 찾아낸다. 이 과정에서 life가 0이거나 이미 얼리어덥터인 친구는 제외한다.
3. 얼리 어덥터 친구를 찾아내면 (life가 0이 아니고, 이미 얼리 어덥터도 아니다.) 얼리어덥터 친구들 중에서 아직 개화가 되지 않은 친구들(라이프가 0이 아닌 친구들)의 라이프를 깍아주고, 라이프가 1이라면 queue에 넣어준다.

이러면 2번과 3번이 반복된다. 그리고 2번에서 얼리 어덥터 친구를 찾아낼 때마다, 정답 값을 1씩 증가시켜주고, 모든 탐색이 완료되면 종료된다.

